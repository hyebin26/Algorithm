## 짝지어 제거하기
### 문제 설명
짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.

예를 들어, 문자열 S = baabaa 라면

b aa baa → bb aa → aa →

의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.

제한사항
- 문자열의 길이 : 1,000,000이하의 자연수
- 문자열은 모두 소문자로 이루어져 있습니다.

### 나의풀이 
1. 우선 s 문자열을 배열로 바꾸고 for문으로 arr[i] === arr[i + 1]이 같으면 arr.splice로 arr[i]와 arr[i+1]를 삭제한다.
2. 그리고 i를 초기화하고 arr의 길이가 0이면 1을 0이 아니면 0을 리턴한다.
- 효율성 통과실패 
- 이유 : 만약 s가 length가 1000이고 998번째에 연속으로 같은 값이 있다면 i를 다시 0으로 만들고 다시 for문이 돌아가야 하므로 효율성이 떨어진다.
- 왔던 길을 다시 한번 더 가야 한다 => 효율성이 떨어진다.
```jsx
function solution(s){
    let arr = s.split("");
    for(let i = 0; i<=arr.length-1;i++){
        if(arr[i] === arr[i + 1]){
            arr.splice(i,2);
            i = -1;
        }
    } 
    return arr.length === 0 ? 1 : 0;
}
```
### 다른사람풀이
1. for문으로 arr의 마지막 요소와 s[i]가 같지 않으면 arr.push(s[i])를 하고 같을 시 arr.pop()으 arr의 마지막 요소를 제거해준다.
2. 그리고 arr.length 가 0보다 크면 0 아니면 1을 리턴한다.
- arr 배열의 마지막 요소와 s[i]와의 비교이므로 속도가 빠르다.
- 나의 풀이를 보면 i를 0으로 초기화해서 이미 돌았던 i를 다시 한번 더 돌아야하는데 이 풀이는 이것을 방지하기 위해서 새로운 배열에 i를 넣고 s[i]( 나의 풀이에서 arr[i+1] )와의 비교를 하였다.
```jsx
function solution(s){
    let arr = [];
    for(let i = 0;i < s.length;i++){
        if(arr[arr.length-1] !== s[i]){
           arr.push(s[i])
      }else{
           arr.pop();
      }
    }
    return (arr.length>0) ? 0 : 1;
}
```
